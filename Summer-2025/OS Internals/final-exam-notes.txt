### ✅ **1. Introduction**

* **What is a system?** A collection of interconnected components.
* **What is an OS?** Software that manages hardware and software resources.

---

### ✅ **2. Design Principles**

* **User goals:** Reliable, fast, safe, easy to use.
* **System goals:** Easy to design, maintain, flexible, efficient.
* **Mechanism vs Policy:** Mechanism = how things work, Policy = what should be done.
* **Languages:** OSs often written in C (portable), with some assembly.
* **Protections:** Memory, I/O, CPU, programs from each other.
* **Structure:**

  * *Layered:* Clear abstraction, overhead.
  * *Monolithic:* Entire OS in kernel space, fast but complex.
  * *Microkernel:* Minimal core, modular.
* **Kernel Mode vs User Mode:** Kernel mode has full access; system calls are used to switch.
* **I/O Access Types:** Interrupt-based, memory-mapped, port-mapped.
* **Runtime Stack:** ESP (top of stack), EBP (frame base).

---

### ✅ **3. Hardware and Booting**

* **Components:** CPU, RAM, storage, motherboard.
* **Boot Process:**

  1. Power on (PSU)
  2. BIOS/UEFI loads MBR
  3. Bootloader loads kernel
  4. Kernel initializes system
* **Real Mode vs Protected Mode:**

  * Real: 16-bit, legacy BIOS access.
  * Protected: 32-bit, supports multitasking, paging.
* **HAL:** Interface layer between hardware and OS.
* **Display/Keyboard:** VGA text mode, memory at `0xB8000`, keyboard ports `0x60`/`0x64`.

---

### ✅ **4. Processes**

* **Process:** Instance of a program (e.g., Chrome tab).
* **Process Memory:** Code, data, heap, stack.
* **IPC:** Shared memory, files, message passing.
* **Process States:** New → Ready → Running → Waiting → Terminated.
* **Linux Process Creation:**

  * `fork()`: Duplicates process.
  * `execve()`, `execlp()`, `execvp()`: Replaces process image.
  * `waitpid()`: Wait for child.
  * `exit()`, `kill()`: Terminate.
* **PCB:** Tracks registers, state, memory, files.

---

### ✅ **5. Threads**

* **Thread:** Lightweight process unit.
* **Multithreading vs Multiprocessing:**

  * Threads share memory; processes do not.
* **Thread Models:**

  * *Many-to-One:* All user threads mapped to one kernel thread.
  * *One-to-One:* Each user thread has a kernel thread.
  * *Many-to-Many:* n user threads ↔ m kernel threads.
* **POSIX APIs:** `pthread_create`, `pthread_exit`, `pthread_join`, `pthread_yield`.
* **Contention Scope:**

  * *PCS:* User-level scheduling.
  * *SCS:* Kernel-level scheduling.

---

### ✅ **6. CPU Scheduling**

* **Goals:** High CPU utilization, low waiting/turnaround time.
* **Algorithms:**

  * *FIFO:* Simple, bad for long tasks.
  * *Round Robin:* Fair, time-sliced.
  * *SPN/SRTF:* Optimal wait time but starvation risk.
  * *MLFQ:* Adapts based on CPU/I/O behavior.
  * *Lottery:* Probabilistic fairness.
* **Metrics:**

  * Throughput, turnaround time, waiting time, response time.

---

### ✅ **7. Main Memory**

* **Addresses:**

  * *Physical:* Actual location.
  * *Virtual:* Seen by process.
* **Relocation:**

  * *Static:* Fixed when loaded.
  * *Dynamic:* Uses base/limit registers.
* **Allocation:**

  * *First Fit, Best Fit, Worst Fit.*
* **Fragmentation:**

  * *External:* Between holes.
  * *Internal:* Wasted in fixed blocks.
* **Paging:**

  * Fixed-size pages/frames.
  * Page Table: Maps pages → frames.
  * TLB: Caches page table entries.

---

### ✅ **8. File Systems**

* **Structure:** Boot sector → FAT tables → root directory → data.
* **FAT12:** Used in class project.
* **Directories:** Metadata, file blocks.
* **Allocation:**

  * *Linked, Indexed, Multi-level.*
* **Performance:** Seek time, block size.
* **Inodes:** UNIX way of indexing.

---

### ✅ **9. I/O Systems**

* **Architecture:** Bus → Port → Controller → Device.
* **Polling vs Interrupts:** Polling is constant checking; interrupts signal when ready.
* **DMA:** Direct memory access, bypasses CPU.
* **Buffering:** Speeds up I/O transfers.

---

### ✅ **10. Networks & Distributed Systems**

* **Distributed vs Parallel:** Distributed = separate machines, Parallel = shared memory.
* **Design Goals:** Transparency, reliability, performance.
* **Models:** Client/server, RPC.
* **NFS:** Sun's Network File System.
* **Caching:** Consistency, stateful/stateless.

---

### ✅ **11. Protection**

* **Objects & Domains:** Access control via user/process domain.
* **Access Matrix:** Defines access rights.
* **UNIX:** Domain = user.
* **Multics:** Domain = ring of protection.

---